<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>Ray Casting</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/spectrum/1.8.0/spectrum.min.css">
</head>
<div class="header">
    Ray Casting
</div>
<div id="sidebar" class="sidebar">
    <br><br>
    <p>The Sphere is placed at (0,0,0), with Radius = <span id="r_value"></span></p>
    <p>Radius of Sphere 0.05 <input type="range" min="0.005" max="0.05" value="0.05" class="myslider" step="0.0001"
                                    id="r"> 0.05</p>

    <p>Bright/Dark Diffuse Style <input type="range" min="0.0" max="1.0" value="0.8" class="myslider" step="0.0001"
                                   id="bright"></p>
    <p>Bright/Dark Diffuse Style <input type="range" min="0.0" max="1.0" value="0.2" class="myslider" step="0.0001"
                                 id="dark"></p>
    <p>Specular Sharpness <input type="range" min="0.01" max="1.0" value="0.2" class="myslider" step="0.0001"
                                 id="sharp"></p>
    <p>Light Color <input type="color" id="color" value="#ffffff"></p>
    ---------------------------------------------------------------------------------------
    <p>Cartesian Coordinate</p>
    <img src="xyz.jpg" width="150">
    <br><br>
    <p>z<input type="range" min="-1.0" max="1.0" value="1" class="myslider" step="0.0001" id="z">
    </p>

    <p>y<input type="range" min="-1.0" max="1.0" value="0" class="myslider" step="0.0001"
                                 id="y"></p>

    <p>x<input type="range" min="-1.0" max="1.0" value="0" class="myslider" step="0.0001"
                                 id="x"></p>
    <p> (x, y, z) = ( <span id="x_value"></span>, <span id="y_value"></span>, <span id="z_value"></span> ) </p>
    <br>
</div>

<canvas id="canvas"></canvas>
<!-- vertex shader -->
<script id="vertex-shader-3d" type="x-shader/x-vertex">
    attribute vec4 a_position;
    attribute vec2 texcoord;
    varying vec4 v_position;

    void main() {
        v_position = a_position;
        gl_Position = a_position;
    }
</script>

<!-- fragment shader -->
<script id="fragment-shader-3d" type="x-shader/x-fragment">
    precision mediump float;
    #define MAX_TH 10000000.0

    varying vec4 v_position;

    uniform vec3 color;
    uniform float r;
    uniform float bright;
    uniform float dark;
    uniform float sharp;

    uniform vec3 coordinate; // xyz coordinate
    vec3 p_light = vec3(1., 1., 1.); // light position

    vec4 diffuse(vec3 n, vec3 ph) {
        vec4 result = vec4(0., 0., 0., 1.);

        vec3 v_light = normalize(p_light - ph);

        float cos = (dot(n, v_light) + 1.0) / 2.0;
        float color_dark;
        float color_bright;

        if (dark > bright) {
            color_dark = bright;
            color_bright = dark;
        } else {
            color_dark = dark;
            color_bright = bright;
            if (dark == bright) {
                color_bright += 0.001;
            }
        }

        float t = (cos - color_dark) / (color_bright - color_dark);

        if (t > 1.0)
            t = 1.0;
        if (t < 0.0)
            t = 0.0;

        result += t * vec4(color, 1.0);
        return result;
    }

    vec3 spec(vec3 n, vec3 npe, vec3 ph) {
        vec3 spec = vec3(0.0, 0.0, 0.0);

        vec3 v_light = normalize(p_light - ph);

        vec3 RVector = -v_light + 2.0 * dot(n, v_light) * n;
        float temp = dot(RVector, -npe);
        if (temp < 0.0)
            temp = 0.0;
        float specular = pow(temp, sharp * 100.);
        spec += color * specular;
        return spec;
    }

    float general_quadrics_th(
        float a02, float a12, float a22, float a21, float a00,
        float s0, float s1, float s2,
        vec3 v2, vec3 vup, vec3 pc,
        vec3 pe, vec3 npe) {

        // find roots
        vec3 n0 = normalize(cross(vup, v2));
        vec3 n1 = normalize(cross(n0, v2));
        vec3 n2 = normalize(v2);

        float A = a02 * dot(n0, npe) * dot(n0, npe) / (s0 * s0) + a12 * dot(n1, npe) * dot(n1, npe) / (s1 * s1) + a22 * dot(n2, npe) * dot(n2, npe) / (s2 * s2);
        float B = 2.0 * a02 * dot(n0, npe) * dot(n0, pe - pc) / (s0 * s0) + 2.0 * a12 * dot(n1, npe) * dot(n1, pe - pc) / (s1 * s1) + 2.0 * a22 * dot(n2, npe) * dot(n2, pe - pc) / (s2 * s2) + a21 * dot(n2, npe) / s2;
        float C = a02 * dot(n0, pe - pc) * dot(n0, pe - pc) / (s0 * s0) + a12 * dot(n1, pe - pc) * dot(n1, pe - pc) / (s1 * s1) + a22 * dot(n2, pe - pc) * dot(n2, pe - pc) / (s2 * s2) + a21 * dot(n2, pe - pc) / s2 + a00;
        float delta = B * B - 4.0 * A * C;

        if (delta >= 0.0 && -B - sqrt(delta) >= 0.0) {
            float th = (-B - sqrt(delta)) / (2.0 * A);
            return th;
        } else {
            return MAX_TH;
        }
    }

    vec4 general_quadrics(
        float a02, float a12, float a22, float a21, float a00,
        float s0, float s1, float s2,
        vec3 v2, vec3 vup, vec3 pc,
        vec3 pe, vec3 npe) {

        // find roots
        vec3 n0 = normalize(cross(vup, v2));
        vec3 n1 = normalize(cross(n0, v2));
        vec3 n2 = normalize(v2);

        float A = a02 * dot(n0, npe) * dot(n0, npe) / (s0 * s0) + a12 * dot(n1, npe) * dot(n1, npe) / (s1 * s1) + a22 * dot(n2, npe) * dot(n2, npe) / (s2 * s2);
        float B = 2.0 * a02 * dot(n0, npe) * dot(n0, pe - pc) / (s0 * s0) + 2.0 * a12 * dot(n1, npe) * dot(n1, pe - pc) / (s1 * s1) + 2.0 * a22 * dot(n2, npe) * dot(n2, pe - pc) / (s2 * s2) + a21 * dot(n2, npe) / s2;
        float C = a02 * dot(n0, pe - pc) * dot(n0, pe - pc) / (s0 * s0) + a12 * dot(n1, pe - pc) * dot(n1, pe - pc) / (s1 * s1) + a22 * dot(n2, pe - pc) * dot(n2, pe - pc) / (s2 * s2) + a21 * dot(n2, pe - pc) / s2 + a00;
        float delta = B * B - 4.0 * A * C;

        if (delta >= 0.0 && -B - sqrt(delta) >= 0.0) {
            float th = (-B - sqrt(delta)) / (2.0 * A);
            vec3 ph = pe + th * npe;
            vec3 fp = 2.0 * a02 * n0 * dot(n0, ph - pc) / (s0 * s0) + 2.0 * a12 * n1 * dot(n1, ph - pc) / (s1 * s1) + 2.0 * a22 * n2 * dot(n2, ph - pc) / (s2 * s2) + a21 * n2 / s2;
            fp = normalize(fp);
            return diffuse(fp, ph) + vec4(spec(fp, npe, ph), 1.);
        } else {
            return vec4(0., 0., 0., 1.);
        }
    }

    void main() {
        vec3 p = vec3(v_position[0], v_position[1], v_position[2]);
        vec3 pe = vec3(coordinate[0], coordinate[1], coordinate[2]);

        // quadrics parameters --------------------------------------------------------------
        vec3 npe = normalize(p - pe);
        vec3 v2 = vec3(0., 0., 1.);
        vec3 vup = vec3(1., 0., 0.);


        vec3 pc1 = vec3(0.0, 0.0, 0.0);
        vec3 pc2 = vec3(0.2, 0.4, 0.1);
        vec3 pc3 = vec3(-0.1, -0.2, 0.1);

        float th_min = MAX_TH;
        float th1 = general_quadrics_th(1., 1., 1., 0., -1., r, r, r, v2, vup, pc1, pe, npe);
        float th2 = general_quadrics_th(1., 1., 1., 0., -1., r, r, r, v2, vup, pc2, pe, npe);
        float th3 = general_quadrics_th(1., 1., 1., 0., -1., r, r, r, v2, vup, pc3, pe, npe);
        vec4 color;
        if (th1 < th_min) {
            color = general_quadrics(1., 1., 1., 0., -1., r, r, r, v2, vup, pc1, pe, npe);
            th_min = th1;
        }

        if (th2 < th_min) {
            color = general_quadrics(1., 1., 1., 0., -1., r, r, r, v2, vup, pc2, pe, npe);
            th_min = th2;
        }

        if (th3 < th_min) {
            color = general_quadrics(1., 1., 1., 0., -1., r, r, r, v2, vup, pc3, pe, npe);
            th_min = th3;
        }

        if (th_min == MAX_TH) {
            color = vec4(0., 0., 0., 1.);
        }

        gl_FragColor = color;
    }
</script>

<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="script.js"></script>



<script>
    var sliderZ = document.getElementById("z");
    var outputZ = document.getElementById("z_value");
    outputZ.innerHTML = sliderZ.value;

    sliderZ.oninput = function () {
        outputZ.innerHTML = this.value;
    }
</script>


<script>
    var sliderX = document.getElementById("x");
    var outputX = document.getElementById("x_value");
    outputX.innerHTML = sliderX.value;

    sliderX.oninput = function () {
        outputX.innerHTML = this.value;
    }
</script>

<script>
    var sliderY = document.getElementById("y");
    var outputY = document.getElementById("y_value");
    outputY.innerHTML = sliderY.value;

    sliderY.oninput = function () {
        outputY.innerHTML = this.value;
    }
</script>

<script>
    var sliderR = document.getElementById("r");
    var outputR = document.getElementById("r_value");
    outputR.innerHTML = sliderR.value;

    sliderR.oninput = function () {
        outputR.innerHTML = this.value;
    }
</script>

<body>
</body>
</html>
